{"version":3,"file":"index.js","sources":["../src/list-diff.js"],"sourcesContent":["export default diff;\n\nfunction diff(oldList, newList, key) {\n  const oldListKeys = getKeys(oldList, key);\n  const newListKeys = getKeys(newList, key);\n  const oldListLength = oldList.length;\n  const newListLength = newList.length;\n  const diffed = oldList.slice();\n  const moves = [];\n\n  // Not a key was provied, don't diff.\n  if (noKeys(oldListKeys) && noKeys(newListKeys))\n    return {\n      diffed,\n      moves\n    };\n  // record the move of the last element.\n  let indexDeltas = new Array(oldListLength).fill(0);\n  let _physicalIndex;\n\n  newListKeys.forEach((key, newIndex) => {\n    let _physicalIndex = oldListKeys.indexOf(key);\n\n    if (_physicalIndex === -1) {\n      // Element doesn't exist in `newList` yet. Tell it to\n      // insert it.\n      moves.push({\n        type: 'INSERT',\n        index: newIndex,\n        item: newList[newIndex]\n      });\n      diffed.splice(newIndex, 0, newList[newIndex]);\n\n      // positions of all unprocessed elements should take this delta.\n      indexDeltas[oldListLength - 1]++;\n    } else {\n      let oldIndex = _physicalIndex;\n\n      for (let i = oldListLength - 1; i >= _physicalIndex; i--) {\n        oldIndex += indexDeltas[i];\n      }\n\n      // If it is already in place, don't do anything.\n      if (newIndex === oldIndex)  return;\n\n      moves.push({\n        type: 'MOVE',\n        from: oldIndex, \n        to: newIndex\n      });\n      let _elem = diffed.splice(oldIndex, 1)[0];\n      diffed.splice(newIndex, 0, _elem)\n\n      // It is impossible to move element from front to back.\n      indexDeltas[_physicalIndex]++;\n    }\n  });\n\n  // remove extra.\n  oldListKeys.forEach((key, i) => {\n    \n    if (newListKeys.indexOf(key) === -1) {\n      moves.push({\n        type: 'REMOVE',\n        index: newListLength  // all extra items must've been moved to end.\n      });\n      diffed.splice(newListLength, 1);\n    }\n  });\n\n  return {\n    diffed,\n    moves\n  };\n}\n\n// Elements with no `key` field is to be removed.\nfunction getKeys(list, key) {\n  return list.map((item, i) => {\n    if (key && item) {\n      return typeof key === 'function'\n        ? key(item)\n        : item[key];\n    } else  return void 0;\n  });\n}\n\n\nfunction noKeys(list) {\n  for (const item of list)\n    if (item !== void 0)\n      return false;\n\n  return true;\n}"],"names":["getKeys","list","key","map","item","i","noKeys","oldList","newList","oldListKeys","newListKeys","oldListLength","length","newListLength","diffed","slice","moves","indexDeltas","Array","fill","forEach","newIndex","_physicalIndex","indexOf","push","type","index","splice","oldIndex","from","to","_elem"],"mappings":"gLA6EA,SAASA,EAAQC,EAAMC,GACrB,OAAOD,EAAKE,IAAI,CAACC,EAAMC,IACjBH,GAAOE,EACa,mBAARF,EACVA,EAAIE,GACJA,EAAKF,QACH,GAKZ,SAASI,EAAOL,GACd,IAAK,MAAMG,KAAQH,EACjB,QAAa,IAATG,EACF,OAAO,EAEX,OAAO,SA3FT,SAAcG,EAASC,EAASN,GAC9B,MAAMO,EAAcT,EAAQO,EAASL,GAC/BQ,EAAcV,EAAQQ,EAASN,GAC/BS,EAAgBJ,EAAQK,OACxBC,EAAgBL,EAAQI,OACxBE,EAASP,EAAQQ,QACjBC,KAGN,GAAIV,EAAOG,IAAgBH,EAAOI,GAChC,OACEI,OAAAA,EACAE,MAAAA,GAGJ,IAAIC,EAAc,IAAIC,MAAMP,GAAeQ,KAAK,GAqDhD,OAlDAT,EAAYU,QAAQ,CAAClB,EAAKmB,KACxB,IAAIC,EAAiBb,EAAYc,QAAQrB,GAEzC,IAAwB,IAApBoB,EAGFN,EAAMQ,MACJC,KAAM,SACNC,MAAOL,EACPjB,KAAMI,EAAQa,KAEhBP,EAAOa,OAAON,EAAU,EAAGb,EAAQa,IAGnCJ,EAAYN,EAAgB,SACvB,CACL,IAAIiB,EAAWN,EAEf,IAAK,IAAIjB,EAAIM,EAAgB,EAAGN,GAAKiB,EAAgBjB,IACnDuB,GAAYX,EAAYZ,GAI1B,GAAIgB,IAAaO,EAAW,OAE5BZ,EAAMQ,MACJC,KAAM,OACNI,KAAMD,EACNE,GAAIT,IAEN,IAAIU,EAAQjB,EAAOa,OAAOC,EAAU,GAAG,GACvCd,EAAOa,OAAON,EAAU,EAAGU,GAG3Bd,EAAYK,QAKhBb,EAAYW,QAAQ,CAAClB,EAAKG,MAEU,IAA9BK,EAAYa,QAAQrB,KACtBc,EAAMQ,MACJC,KAAM,SACNC,MAAOb,IAETC,EAAOa,OAAOd,EAAe,OAK/BC,OAAAA,EACAE,MAAAA"}